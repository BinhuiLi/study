1、vue是什么

    一套用于构建用户界面的渐进式javaScript框架

    渐进式：vue可以自底向上的应用

    简单应用：只要一个轻量小巧的核心库

    复杂应用：可以引入各式各样的vue插件

2、vue的特点

    1、采用组件化模式、提高代码复用率，更好维护

    2、声明式编程，让编程人员无需直接操作DOM，提高开发效率

    3、使用虚拟DOM+优秀的DIFF算法，尽量复用DOM节点

3、初始vue

    1、想让vue工作，就必须创建一个vue实例，且要传入一个配置对象

    2、容器中的代码依然符合html规范，只不过混入了一些特殊的vue语法

    3、容器中的代码被称为【vue模板】

    4、vue实例和容器是一一对应的

    5、真实开发中只有一个vue实例，并且会配合者主键一起使用

    6、{{xxx}}中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性

    7、一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新

4、vue模板语法

    1、插值语法：

    功能：用于解析标签体内容

    写法：{{xxx}} xx是js表达式，且可以直接读取到data中的所有属性

    2、指令语法：

    功能：用于解析标签{包括标签属性、标签内容、绑定事件....}

    举例：v-bind:href=''xxx''或简写为 :href="xxx",xxx同样为js表达式，且可以直接读取到data中的所有属性

    备注：vue中有很多的指令，且格式都为：v-???

5、vue中有两种数据绑定的方法

    1、单项绑定（v-bind）：数据只能从data流向页面

    2、双向绑定（v-model）：数据不仅能从data流向页面，还可以从页面流向data

    备注：

    1、双向绑定一般都应用于表单元素上（如：input、select等

    2、v-model:value可以简写为v-model，因为v-model默认收集的就是value的值

6、el和data的两种写法

    1、el的两种写法

    （1）new vue的时候配置el属性

    （2）先创建vue实例，随后通过vue实例..美元符号mount('#容器id'')指定el的值

    2、data的两种写法

    （1）对象式

    （2）函数式

    如何选择：目前两种写法都可以，以后使用组件时，data必须通过函数式，否则会报错

    3、一个重要的原则：

    由vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this将不再是vue实例了

7、MVVM模型

    1、M：模型（model）：data中的数据

    2、V：视图（View）：模板代码

    3、VM：视图模型（ViewModel）：vue实例

    观察发现：

    1、data中的所有属性，最后都出现在了vue实例上

    2、vm身上所有的属性及vue原型上的所有属性，在vue模板中都可以直接使用

8、vue中的数据代理

    vue通过数据劫持实现监测data的数据改变，将并dada中的数据同步到vue的_data中，

    然后通过数据代理将_data中的属性，代理到自身的实例中 生成getter和setter方法

    数据代理的实现：

    通过Object中的definedproperty方法里的getter和setter方法

9、事件的基本使用

    1、使用v-on:xxx 或 @xxx 绑定事件，其中xxx为事件名

    2、事件的回调需要配置在methods对象当中，最终会在vm上

    3、methods中配置的函数，不要用箭头函数！否则this将不会是vm而是window

    4、methods中配置函数，都是vue所管理的函数，this的指向为vm或者组件实例对象

    5、@click=“demo” 和@click=“demo($event)“效果一致，但后者可以传递别的参数

10、 vue中的事件修饰符

    1、prevent：阻止默认事件

    2、stop：阻止事件冒泡

    3、once：事件只被触发一次

    4、capture：使用事件的捕获模式

    5、self：只有event.target是当前元素时才被触发

    6、passive：事件的默认行为立即执行，无需等待事件回调执行完毕

11、键盘事件

    1、vue常用的按键别名：

    回车：enter

    删除：delete    （捕获”删除“和”退格“键）

    退出：esc

    空格：space

    上：up

    下：down

    左：left

    右：right

    2、vue未提供别名的按键，可以使用按键原始的key值去绑定，但要注意如果由两个名字以上组成的按键名要转为全部小写单词之间用"-"连接

    3、系统修饰键（用法特殊） ctrl、alt、shift、meta（win键）

    （1）配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发

    （2）配合keydown使用：正常触发事件

    4、也可以使用keycode去指定具体的按键（不推荐）

    5、Vue.config.keyCode.自定义键名 = 键码，可以自定义一个按键别名

12、计算属性：

    1、定义：要用的属性不存在，要通过已有的属性计算得来

    2、原理：底层借助了Object.defineProperty方法提供的getter和setter方法

    3、get函数什么时候执行？

    （1）当初次读取时会执行一次

    （2）当依赖的数据发生改变时会再次调用

    4、优势：与methods实现相比：内部缓存机制（复用），效率更高，调试方便

    5、备注：

    （1）计算属性最终会出现在vm上，直接读取即可

    （2）如果计算属性要被修改，那必须写set函数去响应修改，且set方法要引起依赖数据的改变

13、监视属性：

    1、当被监视属性的监视的属性发生改变时，handler回调函数自动调用，进行相关操作

    2、监视的属性必须存在，才能进行监视，监视的属性可以时data里的也可以是计算属性

    3、监视的两种写法：

    （1）new Vue时传入watch配置

    （2）通过vue实例.$watch('属性名')监视

14、深度监视

    （1）vue中的watch默认不监视对象内部值的改变（一层）

    （2）配置deep:true 可以监测对象内部值的改变（多层）

    备注：

    （1）vue自身可以监测对象内部值的改变，但vue中提供的watch默认不可以

    （2）使用watch时根据数据具体结构，决定是否采用深度监视

15、绑定样式

    1、class样式

    写法：:class="xxx" xxx可以是字符串、对象、数组

    字符串写法适用于：类名不确定、要动态获取

    对象写法适用于：要绑定多个样式、个数不确定，类名也不确定

    数组写法适用于：要绑定多个样式，个数不确定，类名也不确定，但不确定用不用

    2、style样式

    写法： :style="{fontSize:xxx}"其中xxx是动态值

    :style="{a,b}"其中a,b是样式对象

16、条件渲染

    1、v-if

    写法：

    （1）v-if="表达式"

    （2）v-else-if="表达式"

    （3）v-else="表达式"

    适用于：切换频率较低的场景

    特点：不展示的DOM元素直接移除

    注意：v-if可以和v-else-if、v-else一起使用，但要求结构不能被“打断”

    2、v-show

    写法：v-show="表达式"

    适用于：切换频率较高的场景

    特点：不展示的DOM未被移除，仅仅是通过display:none去将其隐藏

    3、备注：使用v-id的时候，元素可能无法获取到，而使用v-show一定可以获取到

17、列表渲染

    v-for指令

    1、用于展示列表数据

    2、语法：v-for="(item index) in xxx" :key="yyy"     xxx遍历的对象   yyy唯一标识不可重复

    3、可遍历：数组、对象、字符串、指定循环次数

    面试题react、vue中的key有什么作用？（key的内部原理）

    1、虚拟DOM中key的作用：

    key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，

    随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：

    2、虚拟DOM的比较规则：

    （1）旧的虚拟DOM与新的虚拟DOM key值相同

    （a）若虚拟DOM中内容没变，直接使用之前的真实DOM节点

    （b）若虚拟DOM中内容变了，则生成新的真实DOM节点，随后替换掉页面之前的真实DOM节点

    （2）若新的虚拟DOM的key在旧的虚拟DOM中不存在

    直接创建新的真实DOM

    3、用index作为key可能会引发的问题

    1、若数据进行：逆序添加、逆序删除等破坏顺序操作：

    会产生没必要的真实DOM更新  ==》  界面效果没问题，但效率低（因为index是通过数据所在的位置自动生成的自然数，

    逆序操作将破坏原有的顺序，就有可能导致原先不必要新增的真实DOM新增了）

    2、如果结构中还包含输入类的DOM：

    会产生原先输入类真实DOM残留的输入数据与原本要匹配的信息位置错乱 ==》界面有问题

    4、开发中如何选择key？

    1、最好是使用每条数据的唯一标识为key，比如id、手机号、身份证号、学号等唯一值

    2、如果不存在对数据的逆序操作，仅用于渲染列表用于展示使用index或者唯一标识作为key的值都是没有问题的

18、Vue监视数据的原理

    1、vue会监视data中所有层次的数据

    2、如何监测对象中的数据？

    通过setter实现监视，且要new Vue时就传入要监视的数据

    （1）对象中后加的属性，Vue默认不做响应式处理

    （2）如需给后加的属性做响应式，请使用如下API：

    Vue.set(target,propertyName/index,value)或

    vm.$set(target,propertyName/index,value)

    3、如何监视数组中的数据？

    通过包装数组更新元素的方法实现，本质就是做了两件事

    （1）调用原生对应的方法对数组进行更新

    （2）重新解析模板，进行更新页面

    4、在Vue修改数组中的某个元素一定要使用如下方法

    1、使用这些API：push()、pop()、unshift()、shift()、splice()、sort()、reverse()

    2、Vue.set()或vm.$set()

    特别注意：Vue.set()和vm.$set()不能给vm或vm的根数据对象添加属性！！！！

19、收集表单数据：

    若：<inputtype="text"/>，则v-model收集的是value的值，用户输入的就是value的值

    若：<inputtype="radio"/>，则v-model收集的是value的值，且要给标签配置value的值

    若：<inputtype="radio"/>

    1、没有配置input的value的属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）

    2、配置input的value属性：

    （1）v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）

    （2）v-model的初始值是数组，那么收集的就是value组成的数组

    备注：v-model的三个修饰符

    lazy：失去焦点再收集数据

    number：只取开头为数字的部分

    trim：输入的数据去除首尾的空格

20、过滤器

    定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）

    语法：

    1、注册过滤器：Vue.filter(name,cllback(val){}) 或 new Vue({filters:{callback(val){}}})

    2、使用过滤器：{{xxx | 过滤器名称}} 或v-bind:属性="xxx | 过滤器名称"

    备注：

    1、过滤器也可以接受额外参数，多个过滤器可以串联使用

    2、并没有改变原来的数据，是产生新的响应数据

21、内置指令

    我们学习过的指令：

    v-bind：单向绑定解析表达式

    v-model：双向数据绑定

    v-for：遍历数组/对象/字符串

    v-on：绑定事件监听，可简写为@

    v-if：条件渲染（动态控制节点是否存在）

    v-else：条件渲染（动态控制节点是否存在）

    v-show：条件渲染（动态控制节点是否显示）

    v-text:

    1、作用：向其所在节点中渲染文本内容

    2、与插值语法的区别：v-text会替换点节点中的所有内容，{{xxx}}不会

    v-html指令：

    1、作用：向指定节点中渲染节点中的所有内容，{{xxx}}则不会

    2、与插值语法的区别：

    （1）v-html会替换点节点中的所有内容，{{xxx}}则不会

    （2）v-html可以识别html结构

    3、严重注意：v-html有安全性问题：

    （1）在网站主动渲染任意html是非常危险的，容易导致xss攻击

    （2）一定要在可信的内容上才可以使用v-html，永远不要用在用户提交的内容

    v-cloak指令：

    1、本质就是一个特殊属性，Vue实例创建完毕并接管容器后，会删除掉v-vloak属性

    2、使用css配合v-cloak可以解决网速慢时提示出{{xxx}}的问题

    v-once指令：

    1、v-once所在节点在初次动态渲染后，就视为静态内容了

    2、以后数据的改变不会引起v-once所在的结构的更新，可以用于优化性能

    v-pre指令

    1、跳过其所在节点的编译过程

    2、可以利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译

22、自定义指令：

    1、定义语法：

    （1）局部指令：

    new Vue({                               				new Vue({

    directivess:{指令名:配置对象}  		或       		directives:{指令名:回调函数}

    })                                      					})

    （2）全局指令：

    Vue.directive(指令名,配置对象)    或     Vue.directive({指令名,回调函数})

    2、配置对象中常用的三个回调

    （1）bind：指令在于元素成功绑定时执行

    （2）inserted：指令所在的元素被插入页面之后执行

    （3）update：页面被重新解析时执行

    3、备注：

    1、指令定义时不加v-，但使用是要加

    2、指令名如果是多个单词全部小写使用-连接，不用驼峰命

23、生命周期

    什么是生命周期？

    1、又名：生命周期回调函数、生命周期函数、生命周期钩子

    2、是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数

    3、生命周期函数的函数名不可更改，但函数的具体内容由程序员根据具体需求进行编写

    4、生命周期函数中的this指向vm（vue实例对象）或者组件实例对象

    常用的生命周期的钩子

    1、mounted：发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】

    2、beforedestory：清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】

    关于销毁Vue实例

    1、销毁后借助Vue开发工具看不到任何信息

    2、销毁后自定义事件失效，但原生DOM事件依然有效

    3、一般不会在beforedestory操作数据，因为即便操作数据，也不会再触发更新流程

24、非单文件组件

    Vue中使用组件的三大步骤

    1、定义组件（创建组件）

    2、注册组件

    3、使用组件（写组件标签）

    1、如何定义一个组件

    使用Vue.extend(options)创建，其中options和new Vue（options）时传入的options几乎一样，但区别如下：

    1、el不要写，为什么？==》最终所有的组件都要经过一个vm管理，由vm中的el决定服务于哪个容器

    2、data必须写成函数，为什么？==》避免组件被复用时，数据存在引用关系

    备注：使用template可以配置组件结构

    2、如何注册组件

    1、局部注册：靠new Vue的时候传入components选项

    2、全局注册：靠Vue.component(组件名,组件)

    3、编写组件标签

    <组件名></组件名>

几个注意点：

    1、关于组件名：

    一个单词组成：

    第一种写法：首字母小写

    第二种写法：首字母大写

    多个单词组成：

    第一种写法：使用-连接，全部小写

    第二种写法：所有单词首字母大写（需要搭配Vue脚手架使用）

    备注：

    （1）组件名尽可能回避Html中已有的元素名称，例如：h2、H2都不行

    （2）可以使用name配置项指定组件在开发者工具中呈现的名字

    2、关于组件标签：

    第一种写法：`<school></school>`

    第二种写法：`<school/>`

    备注：不用脚手架时，`<school/>`会导致后续组件不能渲染

    3、一个简写形式

    const school = Vue.extend(options) 可简写为 const school = options


25、关于VueComponent：

    1、school组件本质就是一个名为VueComponent的构造函数，且不是程序员自己定义的，是Vue.extend生成的

    2、我们只需要写`<school></school>`，Vue解析时会帮我们创建school组件的实例对象

    3、特别注意：每次调用Vue.extend，返回的都是一个全新的VueCompent

    4、关于this指向

    （1）组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数它们的this都是指向VueComponent的实例对象

    （2）new Vue配置中：data函数、methods中的函数、watch中的函数、computed中的函数它们的this都是指向Vue的实例对象

    5、VueComponent的实例对象简称为vc    Vue的实例对象简称为vm

    ！！！！！！！！！！组件实例对象能不能操作Vue的原型对象？？？？？？？？？？？？？？？

    *********************************************************************把以下弄懂了就知道了** ------------------------------------------------------***

    **代码见    17-非单文件组件    ==》    3-一个重要的内置关系**

    //通过vm的隐式原型属性操作原型对象    追加一个值为99的x属性

    vm.____proto____.x = 99

    //通过vc获取x的值      返回结果为99

    console.log(school.prototype.x)

    //school（一个创建好的组件的名字）代表着Vuecomponent这个构造函数（当`<school></school>`标签被解析时才会创造出VueComponent的实例对象）

    //Vue就是创建Vue实例对象的构造函数

    //返回结果为true   代表着VueComponent构造方法的原型对象的原型对象指向着Vue构造方法的原型对象

    //这也就意味着vc可以拿到vm原型对象上的所有属性 也	可以使用vc操作vm的原型对象

    console.log(school.prototype.__proto下划线下划线 === Vue.prototype)

    ******************************************************************************************************************************************
